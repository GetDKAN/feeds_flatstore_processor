<?php

/**
 * @file
 * Creates Feeds fetcher for storing Feeds results in a unique tables.
 */

/**
 * Implements hook_ctools_plugin_type().
 */
function feeds_flatstore_processor_ctools_plugin_type() {
  return array(
    'plugins' => array(
      'cache' => TRUE,
      'use hooks' => TRUE,
      'classes' => array('handler'),
    ),
  );
}

/**
 * Implements hook_feeds_after_parse().
 */
function feeds_flatstore_processor_feeds_after_parse(FeedsSource $source, FeedsParserResult $result) {
  // Creates table for feed source if it doesn't exist.
  feeds_flatstore_processor_table($source, $result);
}

/**
 * Creates table name based on source id and entity id.
 */
function feeds_flatstore_processor_table_name($source_id, $entity_id, $prefix = 'feeds_datastore') {
  return $prefix . '_' . $source_id . '_' . $entity_id;
}

/**
 * Retrieves table definition or creates one if table does not exist.
 */
function feeds_flatstore_processor_table(FeedsSource $source, $parser_result) {
  $table_name = feeds_flatstore_processor_table_name($source->id, $source->feed_nid);
  // If table exists, just return it.
  if ($table = data_get_table($table_name)) {
    return $table;
  }
  else {
    $title = '';
    $title_result = db_select('node', 'n')
      ->fields('n', array('title'))
      ->condition('nid', $source->feed_nid, '=')
      ->execute()
      ->fetchAssoc();
    if (isset($title_result['title'])) {
      $title = $title_result['title'];
    }
    // If this is a CSV file, get more info.
    if ($source->importer->parser instanceof FeedsCSVParser) {
      $fetcher = get_class($source->importer->fetcher);
      $source = $source->config[$fetcher]['source'];
      if ($source) {
        // This gives us a better range of results for finding data types.
        $example_data = feeds_flatstore_processor_get_csv_results($source);
      }
      else {
        $example_data = $parser_result;
      }
      $types = feeds_flatstore_processor_find_columns($example_data);
    }
    else {
      $types = feeds_flatstore_processor_find_columns($parser_results);
    }
    $schema = feeds_flatstore_processsor_base_schema();
    $field_schema = data_build_schema($types);
    $schema['fields'] = array_merge($field_schema['fields'], $schema['fields']);

    $table = data_create_table($table_name, $schema, $title);
    return $table;
  }
}

/**
 * Creates base schema for flatstore table.
 */
function feeds_flatstore_processsor_base_schema() {
  return array(
    'fields' => array(
      'id' => array(
        'type' => 'serial',
        'size' => 'normal',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'timestamp' => array(
        'description' => 'The Unix timestamp for the data.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => FALSE,
      ),
    ),
    'indexes' => array(
      'id' => array('id'),
      'timestamp' => array('timestamp'),
    ),
    'primary key' => array(
      '0' => 'id',
    ),
  );
}


/**
 * Opens csv file and grabs set amount of rows.
 *
 * This is used for finding database schema since the results of a parsed
 * feeds result will be only 50 rows by default. This is an in relatively
 * inexpensive operation that should only be run once per feed source.
 */
function feeds_flatstore_processor_get_csv_results($filepath, $separator = ",", $limit = 1000) {
  static $size = 10000;
  $handle = fopen($filepath, 'r');
  if ($handle === FALSE) {
    drupal_set_message(t('Could not open !filename', array('!filename' => $filepath)));
    return FALSE;
  }

  $parsed_results = array();
  $rowcount = 0;
  while (($data = fgetcsv($handle, $size, ',')) !== FALSE) {
    $result[] = $data;
    $rowcount++;
    if ($rowcount > $limit) {
      break;
    }
  }
  fclose($handle);
  return $result;
}

/**
 * Finds the schema type for values in an array.
 */
function feeds_flatstore_processor_find_columns($parsed_results, $headers = array()) {
  $colcount = count($parsed_results[0]);
  $rowcount = count($parsed_results);
  if (!$headers) {
    $headers = $parsed_results[0];
  }

  for ($j = 0; $j < $colcount; $j++) {
    $type_counter = array(
      'int' => 0,
      'text' => 0,
      'datetime' => 0,
      'float' => 0,
      'double' => 0,
      'geometry' => 0,
      'varchar' => 0,
    );
    for ($i = 1; $i < $rowcount; $i++) {
      if ($parsed_results[$i][$j] == '') {
        continue;
      }
      // Int.
      if (preg_match('/^-?\d+$/', $parsed_results[$i][$j])) {
        $result['type'][$j] = 'int';
        $type_counter['int']++;
      }
      // Float.
      elseif (preg_match('/^-?(?:\d+|\d*\.\d+)$/', trim($parsed_results[$i][$j]))) {
        $result['type'][$j] = 'float';
        $type_counter['float']++;
      }
      // Double.
      elseif (preg_match('/[^0-9][0-9]+(\.[0-9]+)?[^0-9]/', trim($parsed_results[$i][$j]))) {
        $result['type'][$j] = 'double';
        $type_counter['double']++;
      }
      // Datetime.
      elseif (preg_match("/\d{4}\-\d{2}\-\d{2} \d{2}:\d{2}:\d{2}/", trim($parsed_results[$i][$j])) ||
              preg_match("/\d{2}\-\d{2}\-\d{4} \d{2}:\d{2}:\d{2}/", trim($parsed_results[$i][$j])) ||
              preg_match("/\d{4}\-\d{2}\-\d{2} \d{2}:\d{2}/", trim($parsed_results[$i][$j])) ||
              preg_match("/\d{2}\-\d{2}\-\d{4} \d{2}:\d{2}/", trim($parsed_results[$i][$j])) ||
              preg_match("/\d{4}\/\d{2}\/\d{2}/", trim($parsed_results[$i][$j])) ||
              preg_match("/\d{2}\.\d{2}\.\d{4}/", trim($parsed_results[$i][$j]))) {
        $result['type'][$j] = 'datetime';
        $type_counter['datetime']++;
      }
      else {
        $result['type'][$j] = 'text';
        $type_counter['text']++;
      }
    }
    $max = max($type_counter);
    if ($max == 0) {
      $result['type'][$j] = 'varchar';
    }
    else {
      foreach ($type_counter as $key => $value) {
        if ($value == $max) {
          $result['type'][$j] = $key;
        }
      }
    }
  }
  foreach ($headers as $key => $header) {
    $schema[$header] = $result['type'][$key];
  }
  return $schema;
}


/**
 * Implements hook_feeds_plugins().
 */
function feeds_flatstore_processor_feeds_plugins() {
  $path = drupal_get_path('module', 'feeds_flatstore_processor');

  return array(
    'FeedsFlatstoreProcessor' => array(
      'name' => 'Field Data Processor',
      'description' => 'Imports source data into unique database tables identified by the entity id they are attached to.',
      'help' => 'Imports source data into unique database tables identified by the entity id they are attached to.',
      'handler' => array(
        'parent' => 'FeedsProcessor',
        'class' => 'FeedsFlatstoreProcessor',
        'file' => 'FeedsFlatstoreProcessor.inc',
        'path' => $path,
      ),
    ),
  );
}
